% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/gridworld.R
\name{gridworld}
\alias{gridworld}
\alias{gridworld_init}
\alias{gridworld_s2rc}
\alias{gridworld_rc2s}
\alias{gridworld_matrix}
\alias{gridworld_plot_policy}
\alias{gridworld_plot_transition_graph}
\title{Helper Functions for Gridworld MDPs}
\usage{
gridworld_init(
  dim,
  A = c("up", "right", "down", "left"),
  unreachable_states = NULL,
  absorbing_states = NULL,
  labels = NULL
)

gridworld_s2rc(s)

gridworld_rc2s(xy)

gridworld_matrix(model, epoch = 1L, what = "states")

gridworld_plot_policy(
  model,
  epoch = 1L,
  arrows = TRUE,
  states = TRUE,
  labels = TRUE,
  absorbing_state = FALSE,
  main = NULL,
  cex = 1.5,
  offset = 0.7,
  ...
)

gridworld_plot_transition_graph(
  x,
  hide_unreachable_states = TRUE,
  remove.loops = TRUE,
  vertex.color = "gray",
  vertex.shape = "square",
  vertex.size = 40,
  edge.arrow.size = 0.3,
  margin = 0.2,
  main = NULL,
  ...
)
}
\arguments{
\item{dim}{vector of length two with the x and y extent of the gridworld.}

\item{A}{vector with four action labels that move the agent up, right, down,
and left.}

\item{unreachable_states}{a vector with state labels for unreachable states.
These states will be excluded.}

\item{absorbing_states}{a vector with state labels for absorbing states.}

\item{labels}{logical; show state labels.}

\item{s}{a state label.}

\item{xy}{a vector of length two with the x and y coordinate of a
state in the gridworld.}

\item{model, x}{a solved gridworld MDP.}

\item{epoch}{epoch for unconverged finite-horizon solutions.}

\item{what}{What should be returned in the matrix. Options are:
\code{"states"}, \code{"labels"}, \code{"values"}, \code{"actions"}, \code{"absorbing"}, and
\code{"reachable"}.}

\item{arrows}{logical; show arrows instead of action names.}

\item{states}{logical; show state names.}

\item{absorbing_state}{logical; show the value and the action for absorbing states.}

\item{main}{a main title for the plot. Defaults to the name of the problem.}

\item{cex}{expansion factor for the action.}

\item{offset}{move the state labels out of the way (in fractions of a character width).}

\item{...}{further arguments are passed on to \code{igraph::plot.igraph()}.}

\item{hide_unreachable_states}{logical; do not show unreachable states.}

\item{remove.loops}{logical; do not show transitions from a state back to itself.}

\item{vertex.color, vertex.shape, vertex.size, edge.arrow.size}{see \code{igraph::igraph.plotting}.}

\item{margin}{a single number specifying the margin of the plot. Can be used if the
graph does not fit inside the plotting area.}
}
\description{
Helper functions for gridworld MDPs to convert between state names and
gridworld positions, and for visualizing policies.
}
\details{
Gridworlds are implemented with state names \code{s(row,col)}, where
\code{row} and \code{col} are locations in the matrix representing the gridworld.
The actions are \code{"up"}, \code{"right"},  \code{"down"}, and  \code{"left"}.

\code{gridworld_init()} initializes a new gridworld creating a matrix
of states with the given dimensions. Other action names
can be specified, but they must have the same effects in the same order
as above. Unreachable states (walls) and absorbing state can be defined.
Tis information is used to create a default transition function.

Several other helper functions
are provided.
}
\examples{
# Define a gridworld: The Dyna Maze from Chapter 8 in the RL book
gw <- gridworld_init(c(6,9), 
                unreachable_states = c("s(2,3)", "s(3,3)", "s(4,3)",
                                       "s(5,6)", 
                                       "s(1,8)", "s(2,8)", "s(3,8)"),
                absorbing_states = "s(1,9)",
                labels = list("s(1,9)" = "G",
                              "s(3,1)" = "S"))
gw

# display the state labels in the gridworld
gridworld_matrix(gw)

# regular moves in the gridworld
gw$T("right", "s(1,1)", "s(1,2)")
gw$T("right", "s(2,2)", "s(2,3)")  ### we cannot move into an unreachable state
gw$T("right", "s(2,2)", "s(2,2)")  ### but the agent stays in place

# convert between state names and row/column indices
gridworld_s2rc("s(1,1)")
gridworld_rc2s(c(1,1))

Dyna_maze <- MDP(
  states = gw$states,
  actions = gw$actions,
  transition_prob = gw$T,
  reward = rbind(R_(value = 0), R_(end.state = "s(1,9)", value = +1)),
  discount = 0.95,
  start = "s(3,1)",
  info = gw$info,
  name = "Dyna Maze"
  )

Dyna_maze

gridworld_plot_transition_graph(Dyna_maze, 
    vertex.label = NA, vertex.size = 20)

sol <- solve_MDP(Dyna_maze)
gridworld_plot_policy(sol)


# Use the existing Maze gridworld 
data(Maze)

# show the layout
gridworld_matrix(Maze)
gridworld_matrix(Maze, what = "labels")

# visualize the transition graph
gridworld_plot_transition_graph(Maze)

# translate between state labels and gridworld locations
gridworld_rc2s(c(1,1))

# for solved MDPs we can look at state values and policy actions
sol <- solve_MDP(Maze)
policy(sol)
gridworld_matrix(sol, what = "values")
gridworld_matrix(sol, what = "actions")

# plot the solved gridworld
gridworld_plot_policy(sol)
gridworld_plot_policy(sol, arrows = FALSE)
}
\seealso{
Other gridworld: 
\code{\link{Cliff_walking}},
\code{\link{Maze}},
\code{\link{Windy_gridworld}}
}
\concept{gridworld}
