% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/gridworld.R
\name{gridworld}
\alias{gridworld}
\alias{gridworld_init}
\alias{gridworld_s2rc}
\alias{gridworld_rc2s}
\alias{gridworld_matrix}
\alias{gridworld_plot_policy}
\alias{gridworld_plot_transition_graph}
\title{Helper Functions for Gridworld MDPs}
\usage{
gridworld_init(
  dim,
  A = c("up", "right", "down", "left"),
  unreachable_states = NULL
)

gridworld_s2rc(s)

gridworld_rc2s(xy)

gridworld_matrix(model, epoch = 1L, what = "states")

gridworld_plot_policy(
  model,
  epoch = 1L,
  arrows = TRUE,
  states = TRUE,
  labels = TRUE,
  absorbing_state = FALSE,
  main = NULL,
  cex = 1.5,
  offset = 0.7,
  ...
)

gridworld_plot_transition_graph(
  x,
  hide_unreachable_states = TRUE,
  remove.loops = TRUE,
  vertex.color = "gray",
  vertex.shape = "square",
  vertex.size = 40,
  edge.arrow.size = 0.3,
  margin = 0.2,
  main = NULL,
  ...
)
}
\arguments{
\item{dim}{vector of length two with the x and y extent of the gridworld.}

\item{A}{vector with four action labels that move the agent up, right, down,
and left.}

\item{unreachable_states}{a vector with state labels for unreachable states.
These states will be excluded.}

\item{s}{a state label.}

\item{xy}{a vector of length two with the x and y coordinate of a
state in the grid world.}

\item{model, x}{a solved grid world MDP.}

\item{epoch}{epoch for unconverged finite-horizon solutions.}

\item{what}{What should be returned in the matrix. Options are:
\code{"states"}, \code{"labels"}, \code{"values"}, \code{"actions"}, \code{"absorbing"}, and
\code{"reachable"}.}

\item{arrows}{logical; show arrows instead of action names.}

\item{states}{logical; show state names.}

\item{labels}{logical; show state labels.}

\item{absorbing_state}{logical; show the value and the action for absorbing states.}

\item{main}{a main title for the plot. Defaults to the name of the problem.}

\item{cex}{expansion factor for the action.}

\item{offset}{move the state labels out of the way (in fractions of a character width).}

\item{...}{further arguments are passed on to \code{igraph::plot.igraph()}.}

\item{hide_unreachable_states}{logical; do not show unreachable states.}

\item{remove.loops}{logical; do not show transitions from a state back to itself.}

\item{vertex.color, vertex.shape, vertex.size, edge.arrow.size}{see \code{igraph::igraph.plotting}.}

\item{margin}{a single number specifying the margin of the plot. Can be used if the
graph does not fit inside the plotting area.}
}
\description{
Helper functions for grid world MDPs to convert between state names and
grid world positions, and for visualizing policies.
}
\details{
Gridworlds are implemented with state names \code{s(row,col)}, where
\code{row} and \code{col} are locations in the matrix representing the grid world.
The actions are \code{"up"}, \code{"right"},  \code{"down"}, and  \code{"left"}.

\code{gridworld_init()} initializes a new grid world creating a matrix
of states with the given dimensions. Other action names
can be specified, but they must have the same effects in the same order
as above.

Several other helper functions
are provided.
}
\examples{
# define a gridworld as a matrix with 7 rows and 5 columns 
gw <- gridworld_init(c(7,5), 
                unreachable_states = c("s(2,2)", "s(3,2)", "s(4,2)"))
gw

# display the state labels in the gridworld
gridworld_matrix(gw)

# regular moves in the gridworld
gw$trans_prob("right", "s(1,1)", "s(1,2)")
gw$trans_prob("right", "s(2,1)", "s(2,2)")  ### we cannot move into an unreachable state
gw$trans_prob("right", "s(2,1)", "s(2,1)")  ### but the agent stays in place

# convert between state names and row/column indices
gridworld_s2rc("s(3,3)")
gridworld_rc2s(c(3,3))

# use the Maze grid world 
data(Maze)

# show the layout
gridworld_matrix(Maze)
gridworld_matrix(Maze, what = "labels")

# visualize the transition graph
gridworld_plot_transition_graph(Maze)

# translate between state labels and grid world locations
gridworld_rc2s(c(1,1))

# for solved MDPs we can look at state values and policy actions
sol <- solve_MDP(Maze)
policy(sol)
gridworld_matrix(sol, what = "values")
gridworld_matrix(sol, what = "actions")

# plot the solved grid world
gridworld_plot_policy(sol)
gridworld_plot_policy(sol, arrows = FALSE)
}
\seealso{
Other gridworld: 
\code{\link{Cliff_walking}},
\code{\link{Maze}}
}
\concept{gridworld}
